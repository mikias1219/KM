Here are the programs for the tasks you've listed:

1. Create and display a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertNode(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    cout << "Linked List: ";
    displayList(head);

    return 0;
}
```

2. Create a singly linked list of n nodes and display it in reverse order:
```cpp
#include <iostream>
#include <stack>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertNode(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
}

void displayReverse(Node* head) {
    stack<Node*> nodes;
    Node* temp = head;
    while (temp != nullptr) {
        nodes.push(temp);
        temp = temp->next;
    }
    cout << "Linked List in reverse order: ";
    while (!nodes.empty()) {
        cout << nodes.top()->data << " ";
        nodes.pop();
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    displayReverse(head);

    return 0;
}
```

3. Create a singly linked list of n nodes and count the number of nodes:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertNode(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
}

int countNodes(Node* head) {
    int count = 0;
    Node* temp = head;
    while (temp != nullptr) {
        count++;
        temp = temp->next;
    }
    return count;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    cout << "Number of nodes: " << countNodes(head) << endl;

    return 0;
}
```

4. Insert a new node at the beginning of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertAtBeginning(Node*& head, int data) {
    Node* newNode = createNode(data);
    newNode->next = head;
    head = newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtBeginning(head, 1);
    insertAtBeginning(head, 2);
    insertAtBeginning(head, 3);
    insertAtBeginning(head, 4);
    insertAtBeginning(head, 5);

    cout << "Linked List after insertion: ";
    displayList(head);

    return 0;
}
```

5. Insert a new node at the end of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertAtEnd(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtEnd(head, 1);
    insertAtEnd(head, 2);
    insertAtEnd(head, 3);
    insertAtEnd(head, 4);
    insertAtEnd(head, 5);

    cout << "Linked List after insertion: ";
    displayList(head);

    return 0;
}
```

These programs should help you understand how to work with singly linked lists in C++.
Here are the programs for the tasks you've listed:

6. Insert a node in the middle of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertInMiddle(Node*& head, int data, int position) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        return;
    }
    Node* temp = head;
    int count = 1;
    while (count < position - 1 && temp != nullptr) {
        temp = temp->next;
        count++;
    }
    if (temp == nullptr) {
        cout << "Position out of range." << endl;
        return;
    }
    newNode->next = temp->next;
    temp->next = newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertInMiddle(head, 1, 1); // Insert at beginning
    insertInMiddle(head, 3, 2); // Insert at middle
    insertInMiddle(head, 5, 3); // Insert at end

    cout << "Linked List after insertion: ";
    displayList(head);

    return 0;
}
```

7. Delete the first node of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void deleteFirstNode(Node*& head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    head = head->next;
    delete temp;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    deleteFirstNode(head);

    cout << "Linked List after deletion: ";
    displayList(head);

    return 0;
}
```

8. Delete a node from the middle of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void deleteNode(Node*& head, int position) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    if (position == 1) {
        head = temp->next;
        delete temp;
        return;
    }
    int count = 1;
    while (count < position - 1 && temp != nullptr) {
        temp = temp->next;
        count++;
    }
    if (temp == nullptr || temp->next == nullptr) {
        cout << "Position out of range." << endl;
        return;
    }
    Node* nodeToDelete = temp->next;
    temp->next = temp->next->next;
    delete nodeToDelete;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    deleteNode(head, 3);

    cout << "Linked List after deletion: ";
    displayList(head);

    return 0;
}
```

9. Delete the last node of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void deleteLastNode(Node*& head) {
    if (head == nullptr) {
        return;
    }
    if (head->next == nullptr) {
        delete head;
        head = nullptr;
        return;
    }
    Node* temp = head;
    while (temp->next->next != nullptr) {
        temp = temp->next;
    }
    delete temp->next;
    temp->next = nullptr;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    deleteLastNode(head);

    cout << "Linked List after deletion: ";
    displayList(head);

    return 0;
}
```

10. Search for an existing element in a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

bool search(Node* head, int key) {
    Node* temp = head;
    while (temp != nullptr) {
        if (temp->data == key) {
            return true;
        }
        temp = temp->next;
    }
    return false;
}

int main() {
    Node* head = nullptr;
    insertNode(head, 1);
    insertNode(head, 2);
    insertNode(head, 3);
    insertNode(head, 4);
    insertNode(head, 5);

    int key = 3;
    if (search(head, key)) {
        cout << key << " found in the linked list." << endl;
    } else {
        cout << key << " not found in the linked list." << endl;
    }

    return 0;
}
```

These programs should help you understand how to perform various operations on singly linked lists in C++.
Here are the programs for the tasks you've listed:

11. Convert a singly linked list into a string and return it:
```cpp
#include <iostream>
#include <sstream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

string linkedListToString(Node* head) {
    stringstream ss;
    Node* temp = head;
    while (temp != nullptr) {
        ss << temp->data << " ";
        temp = temp->next;
    }
    return ss.str();
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);

    cout << "Linked list as string: " << linkedListToString(head) << endl;

    return 0;
}
```

12. Convert a singly linked list into an array and return it:
```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

vector<int> linkedListToArray(Node* head) {
    vector<int> arr;
    Node* temp = head;
    while (temp != nullptr) {
        arr.push_back(temp->data);
        temp = temp->next;
    }
    return arr;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);

    vector<int> arr = linkedListToArray(head);
    cout << "Linked list converted to array: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

13. Check if a singly linked list is a palindrome or not:
```cpp
#include <iostream>
#include <stack>
using namespace std;

struct Node {
    char data;
    Node* next;
};

Node* createNode(char data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

bool isPalindrome(Node* head) {
    stack<char> s;
    Node* temp = head;
    while (temp != nullptr) {
        s.push(temp->data);
        temp = temp->next;
    }
    temp = head;
    while (temp != nullptr) {
        char top = s.top();
        s.pop();
        if (top != temp->data) {
            return false;
        }
        temp = temp->next;
    }
    return true;
}

int main() {
    Node* head = nullptr;
    head = createNode('a');
    head->next = createNode('b');
    head->next->next = createNode('b');
    head->next->next->next = createNode('a');

    if (isPalindrome(head)) {
        cout << "The linked list is a palindrome." << endl;
    } else {
        cout << "The linked list is not a palindrome." << endl;
    }

    return 0;
}
```

14. Remove duplicates from a singly unsorted linked list:
```cpp
#include <iostream>
#include <unordered_set>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void removeDuplicates(Node* head) {
    unordered_set<int> seen;
    Node* curr = head;
    Node* prev = nullptr;
    while (curr != nullptr) {
        if (seen.find(curr->data) != seen.end()) {
            prev->next = curr->next;
            delete curr;
            curr = prev->next;
        } else {
            seen.insert(curr->data);
            prev = curr;
            curr = curr->next;
        }
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(2);
    head->next->next->next->next = createNode(4);
    head->next->next->next->next->next = createNode(1);

    cout << "Original linked list: ";
    displayList(head);

    removeDuplicates(head);

    cout << "Linked list after removing duplicates: ";
    displayList(head);

    return 0;
}
```

15. Get the n number of nodes from the end of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

int lengthOfList(Node* head) {
    int length = 0;
    Node* temp = head;
    while (temp != nullptr) {
        length++;
        temp = temp->next;
    }
    return length;
}

Node* getNthFromEnd(Node* head, int n) {
    int length = lengthOfList(head);
    if (length < n) {
        cout << "Invalid value of n." << endl;
        return nullptr;
    }
    Node* slow = head;
    Node* fast = head;
    for (int i = 0; i < n; i++) {
        fast = fast->next;
    }
    while (fast != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    int n = 2;
    Node* nthNode = getNthFromEnd(head, n);
    if (nthNode != nullptr) {
        cout << "The " << n << "th node from the end is: " << nthNode->data << endl;
    }

    return 0;
}
```

These programs should help you understand how to perform various operations on singly linked lists in C++.
Here are the programs for the tasks you've listed:

16. Sum of two linked lists as a new linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

Node* addTwoNumbers(Node* l1, Node* l2) {
    Node* dummy = new Node();
    Node* curr = dummy;
    int carry = 0;

    while (l1 != nullptr || l2 != nullptr || carry != 0) {
        int sum = carry;
        if (l1 != nullptr) {
            sum += l1->data;
            l1 = l1->next;
        }
        if (l2 != nullptr) {
            sum += l2->data;
            l2 = l2->next;
        }
        carry = sum / 10;
        Node* newNode = new Node();
        newNode->data = sum % 10;
        curr->next = newNode;
        curr = curr->next;
    }

    return dummy->next;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* l1 = createNode(2);
    l1->next = createNode(4);
    l1->next->next = createNode(3);

    Node* l2 = createNode(5);
    l2->next = createNode(6);
    l2->next->next = createNode(4);

    Node* result = addTwoNumbers(l1, l2);

    cout << "Sum of the two linked lists: ";
    displayList(result);

    return 0;
}
```

17. Get the nth node in a given singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

Node* getNthNode(Node* head, int n) {
    Node* temp = head;
    int count = 0;
    while (temp != nullptr) {
        if (count == n) {
            return temp;
        }
        count++;
        temp = temp->next;
    }
    return nullptr;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    int n = 3;
    Node* nthNode = getNthNode(head, n);
    if (nthNode != nullptr) {
        cout << "The " << n << "th node is: " << nthNode->data << endl;
    } else {
        cout << "Node not found." << endl;
    }

    return 0;
}
```

18. Remove elements with odd indices from a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void removeOddIndices(Node*& head) {
    if (head == nullptr || head->next == nullptr) {
        return;
    }
    Node* prev = head;
    Node* curr = head->next;
    int index = 1;
    while (curr != nullptr) {
        if (index % 2 != 0) {
            prev->next = curr->next;
            delete curr;
            curr = prev->next;
        } else {
            prev = curr;
            curr = curr->next;
        }
        index++;
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    cout << "Original linked list: ";
    displayList(head);

    removeOddIndices(head);

    cout << "Linked list after removing elements with odd indices: ";
    displayList(head);

    return 0;
}
```

19. Remove elements with even indices from a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void removeEvenIndices(Node*& head) {
    if (head == nullptr || head->next == nullptr) {
        return;
    }
    Node* prev = head;
    Node* curr = head->next;
    int index = 1;
    while (curr != nullptr) {
        if (index % 2 == 0) {
            prev->next = curr->next;
            delete curr;
            curr = prev->next;
        } else {
            prev = curr;
            curr = curr->next;
        }
        index++;
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    cout << "Original linked list: ";
    displayList(head);

    removeEvenIndices(head);

    cout << "Linked list after removing elements with even indices: ";
    displayList(head);

    return 0;
}
```

20. Remove the nth node from the end of a singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void removeNthFromEnd(Node*& head, int n) {
    if (head == nullptr) {
        return;
    }
    Node* fast = head;
    Node* slow = head;
    for (int i = 0; i < n; i++) {
       

 fast = fast->next;
    }
    if (fast == nullptr) {
        head = head->next;
        delete slow;
        return;
    }
    while (fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    Node* temp = slow->next;
    slow->next = slow->next->next;
    delete temp;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    int n = 2;
    cout << "Original linked list: ";
    displayList(head);

    removeNthFromEnd(head, n);

    cout << "Linked list after removing " << n << "th node from end: ";
    displayList(head);

    return 0;
}
```

These programs should help you with the specified operations on singly linked lists in C++.
Here are the programs for the tasks you've listed:

21. Remove duplicates from a sorted singly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void removeDuplicates(Node* head) {
    Node* current = head;
    while (current != nullptr && current->next != nullptr) {
        if (current->data == current->next->data) {
            Node* temp = current->next;
            current->next = current->next->next;
            delete temp;
        } else {
            current = current->next;
        }
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = createNode(1);
    head->next = createNode(1);
    head->next->next = createNode(2);
    head->next->next->next = createNode(3);
    head->next->next->next->next = createNode(3);
    head->next->next->next->next->next = createNode(3);

    cout << "Original linked list: ";
    displayList(head);

    removeDuplicates(head);

    cout << "Linked list after removing duplicates: ";
    displayList(head);

    return 0;
}
```

22. Doubly Linked List:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;
    head->next->next->next = createNode(4);
    head->next->next->next->prev = head->next->next;

    cout << "Doubly linked list: ";
    displayList(head);

    return 0;
}
```

23. Create a doubly linked list and display it in reverse order:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void insertAtBeginning(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
    } else {
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
}

void displayListReverse(Node* head) {
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->prev;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtBeginning(head, 1);
    insertAtBeginning(head, 2);
    insertAtBeginning(head, 3);
    insertAtBeginning(head, 4);
    insertAtBeginning(head, 5);

    cout << "Doubly linked list in reverse order: ";
    displayListReverse(head);

    return 0;
}
```

24. Insert a node at the beginning of a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void insertAtBeginning(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
    } else {
        newNode->next = head;
        head->prev = newNode;
        head = newNode;
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtBeginning(head, 1);
    insertAtBeginning(head, 2);
    insertAtBeginning(head, 3);
    insertAtBeginning(head, 4);
    insertAtBeginning(head, 5);

    cout << "Doubly linked list after insertion: ";
    displayList(head);

    return 0;
}
```

25. Insert a new node at the end of a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void insertAtEnd(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
    } else {
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->prev = temp;
    }
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAt







Here are the programs for the tasks you've listed:

26. Insert a new node at any position in a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void insertAtPosition(Node*& head, int data, int position) {
    Node* newNode = createNode(data);
    if (position == 1) {
        newNode->next = head;
        if (head != nullptr) {
            head->prev = newNode;
        }
        head = newNode;
        return;
    }
    Node* temp = head;
    for (int i = 1; i < position - 1 && temp != nullptr; i++) {
        temp = temp->next;
    }
    if (temp == nullptr) {
        cout << "Invalid position." << endl;
        return;
    }
    newNode->next = temp->next;
    newNode->prev = temp;
    if (temp->next != nullptr) {
        temp->next->prev = newNode;
    }
    temp->next = newNode;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPosition(head, 1, 1);
    insertAtPosition(head, 2, 2);
    insertAtPosition(head, 4, 3);
    insertAtPosition(head, 5, 4);
    insertAtPosition(head, 3, 3); // Insert 3 at position 3

    cout << "Doubly linked list after insertion: ";
    displayList(head);

    return 0;
}
```

27. Delete a node from the beginning of a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void deleteFromBeginning(Node*& head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    head = head->next;
    if (head != nullptr) {
        head->prev = nullptr;
    }
    delete temp;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPosition(head, 1, 1);
    insertAtPosition(head, 2, 2);
    insertAtPosition(head, 3, 3);

    cout << "Doubly linked list before deletion: ";
    displayList(head);

    deleteFromBeginning(head);

    cout << "Doubly linked list after deletion: ";
    displayList(head);

    return 0;
}
```

28. Delete a node from the last node of a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void deleteFromEnd(Node*& head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    if (temp->prev != nullptr) {
        temp->prev->next = nullptr;
    } else {
        head = nullptr;
    }
    delete temp;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPosition(head, 1, 1);
    insertAtPosition(head, 2, 2);
    insertAtPosition(head, 3, 3);

    cout << "Doubly linked list before deletion: ";
    displayList(head);

    deleteFromEnd(head);

    cout << "Doubly linked list after deletion: ";
    displayList(head);

    return 0;
}
```

29. Delete a node from any position in a doubly linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

void deleteAtPosition(Node*& head, int position) {
    if (head == nullptr || position < 1) {
        return;
    }
    Node* temp = head;
    if (position == 1) {
        head = temp->next;
        if (head != nullptr) {
            head->prev = nullptr;
        }
        delete temp;
        return;
    }
    for (int i = 1; temp != nullptr && i < position; i++) {
        temp = temp->next;
    }
    if (temp == nullptr) {
        cout << "Invalid position." << endl;
        return;
    }
    if (temp->prev != nullptr) {
        temp->prev->next = temp->next;
    }
    if (temp->next != nullptr) {
        temp->next->prev = temp->prev;
    }
    delete temp;
}

void displayList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPosition(head, 1, 1);
    insertAtPosition(head, 2, 2);
    insertAtPosition(head, 3, 3);

    cout << "Doubly linked list before deletion: ";
    displayList(head);

    deleteAtPosition(head, 2);

    cout << "Doubly linked list after deletion: ";
    displayList(head);

    return 0;
}
```

30. Find the maximum value in a doubly linked list:
```cpp
#include <iostream>
#include <climits>
using namespace std;

struct Node {
    int data;
    Node* prev;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->prev = nullptr;
    newNode->next = nullptr;
    return newNode;
}

int findMaxValue(Node* head) {


    if (head == nullptr) {
        return INT_MIN;
    }
    int maxVal = head->data;
    Node* temp = head->next;
    while (temp != nullptr) {
        if (temp->data > maxVal) {
            maxVal = temp->data;
        }
        temp = temp->next;
    }
    return maxVal;
}

int main() {
    Node* head = nullptr;
    insertAtPosition(head, 1, 1);
    insertAtPosition(head, 4, 2);
    insertAtPosition(head, 2, 3);
    insertAtPosition(head, 5, 4);
    insertAtPosition(head, 3, 5);

    cout << "Doubly linked list: ";
    displayList(head);

    int maxValue = findMaxValue(head);
    cout << "Maximum value in the linked list: " << maxValue << endl;

    return 0;
}
```

31. Create and display a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void displayCircularList(Node* head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while (temp != head);
    cout << endl;
}

int main() {
    Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = head;

    cout << "Circular linked list: ";
    displayCircularList(head);

    return 0;
}
```

32. Insert a node at the beginning of a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertAtBeginningCircular(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        head->next = head;
        return;
    }
    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->next = head;
    head = newNode;
}

void displayCircularList(Node* head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while (temp != head);
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtBeginningCircular(head, 1);
    insertAtBeginningCircular(head, 2);
    insertAtBeginningCircular(head, 3);

    cout << "Circular linked list after insertion: ";
    displayCircularList(head);

    return 0;
}
```

33. Insert a node at the end of a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertAtEndCircular(Node*& head, int data) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        head->next = head;
        return;
    }
    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->next = head;
}

void displayCircularList(Node* head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while (temp != head);
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtEndCircular(head, 1);
    insertAtEndCircular(head, 2);
    insertAtEndCircular(head, 3);

    cout << "Circular linked list after insertion: ";
    displayCircularList(head);

    return 0;
}
```

34. Insert a node at any position in a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void insertAtPositionCircular(Node*& head, int data, int position) {
    Node* newNode = createNode(data);
    if (head == nullptr) {
        head = newNode;
        head->next = head;
        return;
    }
    if (position == 1) {
        Node* temp = head;
        while (temp->next != head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = head;
        head = newNode;
        return;
    }
    Node* temp = head;
    for (int i = 1; i < position - 1 && temp->next != head; i++) {
        temp = temp->next;
    }
    newNode->next = temp->next;
    temp->next = newNode;
}

void displayCircularList(Node* head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while (temp != head);
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPositionCircular(head, 1, 1);
    insertAtPositionCircular(head, 2, 2);
    insertAtPositionCircular(head, 4, 3);
    insertAtPositionCircular(head, 5, 4);
    insertAtPositionCircular(head, 3, 3); // Insert 3 at position 3

    cout << "Circular linked list after insertion: ";
    displayCircularList(head);

    return 0;
}
```

35. Delete a node from the beginning of a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

void deleteFromBeginningCircular(Node*& head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    while (temp->next != head) {
        temp = temp->next;
    }
    temp->next

 = head->next;
    delete head;
    head = temp->next;
}

void displayCircularList(Node* head) {
    if (head == nullptr) {
        return;
    }
    Node* temp = head;
    do {
        cout << temp->data << " ";
        temp = temp->next;
    } while (temp != head);
    cout << endl;
}

int main() {
    Node* head = nullptr;
    insertAtPositionCircular(head, 1, 1);
    insertAtPositionCircular(head, 2, 2);
    insertAtPositionCircular(head, 3, 3);

    cout << "Circular linked list before deletion: ";
    displayCircularList(head);

    deleteFromBeginningCircular(head);

    cout << "Circular linked list after deletion: ";
    displayCircularList(head);

    return 0;
}
```

36. Search for an element in a circular linked list:
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
};

Node* createNode(int data) {
    Node* newNode = new Node();
    newNode->data = data;
    newNode->next = nullptr;
    return newNode;
}

bool searchCircularList(Node* head, int key) {
    if (head == nullptr) {
        return false;
    }
    Node* temp = head;
    do {
        if (temp->data == key) {
            return true;
        }
        temp = temp->next;
    } while (temp != head);
    return false;
}

int main() {
    Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = head;

    int key = 3;
    if (searchCircularList(head, key)) {
        cout << key << " found in the circular linked list." << endl;
    } else {
        cout << key << " not found in the circular linked list." << endl;
    }

    return 0;
}
```

These programs should help you with the specified operations on doubly linked lists and circular linked lists in C++.